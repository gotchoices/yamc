Only in joe2.1: .jmacsrc
Only in joe2.1: .joerc
Only in joe2.1: .jstarrc
Only in k21: .krc
Only in k21: DEADJOE
diff -r -u joe2.1/Makefile k21/Makefile
--- joe2.1/Makefile	Fri Sep 23 14:04:14 1994
+++ k21/Makefile	Tue Apr  6 15:17:49 1999
@@ -1,15 +1,15 @@
-# Makefile for Joe's Own Editor
+# Makefile for Joe's Own Editor, modified to be K
 
 ###############
 # Configuration
 ###############
 
 # Set where you want joe to go, where you
-# want joe's initialization file (joerc)
+# want joe's initialization file (krc)
 # to go and where you want the man page
 # to go:
 
-WHEREJOE = /usr/local/bin
+WHEREBIN = /usr/local/bin
 WHERERC = /usr/local/lib
 WHEREMAN = /usr/man/man1
 
@@ -28,7 +28,8 @@
 #
 # for some HPUX systems, you need to add:  -D_HPUX_SOURCE
 
-CFLAGS = -O
+#CFLAGS = -O
+CFLAGS = -O2 -DFILE_LOCKING -DUNIQUE_BACKUPS
 
 # You may have to include some extra libraries
 # for some systems
@@ -58,12 +59,8 @@
 
 # That's it!
 
-joe: $(OBJS)
-	$(CC) $(CFLAGS) -o joe $(EXTRALIBS) $(OBJS)
-	rm -f jmacs
-	rm -f jstar
-	ln joe jmacs
-	ln joe jstar
+k: $(OBJS)
+	$(CC) $(CFLAGS) -o k $(EXTRALIBS) $(OBJS)
 
 $(OBJS): config.h
 
@@ -71,32 +68,16 @@
 	$(CC) conf.c -o conf
 	./conf $(WHERERC) $(IDLEOUT)
 
-termidx: termidx.o
-	$(CC) $(CFLAGS) -o termidx termidx.o
-
-install: joe termidx
-	strip joe
-	strip termidx
-	if [ ! -d $(WHEREJOE) ]; then mkdir $(WHEREJOE); chmod a+rx $(WHEREJOE); fi
-	rm -f $(WHEREJOE)/joe $(WHEREJOE)/jmacs $(WHEREJOE)/jstar $(WHEREJOE)/termidx
-	mv joe $(WHEREJOE)
-	ln $(WHEREJOE)/joe $(WHEREJOE)/jmacs
-	ln $(WHEREJOE)/joe $(WHEREJOE)/jstar
-	mv termidx $(WHEREJOE)
+install: k
+	strip k
+	if [ ! -d $(WHEREBIN) ]; then mkdir $(WHEREBIN); chmod a+rx $(WHEREBIN); fi
+	mv k $(WHEREBIN)
 	if [ ! -d $(WHERERC) ]; then mkdir $(WHERERC); chmod a+rx $(WHERERC); fi
-	rm -f $(WHERERC)/joerc $(WHERERC)/jmacsrc $(WHERERC)/jstarrc $(WHEREMAN)/joe.1
-	cp joerc $(WHERERC)
-	cp jmacsrc $(WHERERC)
-	cp jstarrc $(WHERERC)
-	cp joe.1 $(WHEREMAN)
-	chmod a+x $(WHEREJOE)/joe
-	chmod a+x $(WHEREJOE)/jmacs
-	chmod a+x $(WHEREJOE)/jstar
-	chmod a+r $(WHERERC)/joerc
-	chmod a+r $(WHERERC)/jmacsrc
-	chmod a+r $(WHERERC)/jstarrc
-	chmod a+r $(WHEREMAN)/joe.1
-	chmod a+x $(WHEREJOE)/termidx
+	rm -f $(WHERERC)/krc $(WHEREMAN)/k.1
+	cp krc $(WHERERC)
+#	cp k.1 $(WHEREMAN)
+	chmod a+x $(WHEREBIN)/k
+	chmod a+r $(WHERERC)/krc
 
 clean:
 	rm -f $(OBJS) termidx.o conf conf.o config.h
Only in k21: TODO.k
diff -r -u joe2.1/b.c k21/b.c
--- joe2.1/b.c	Mon Sep 19 19:30:06 1994
+++ k21/b.c	Tue Apr  6 15:17:49 1999
@@ -19,6 +19,7 @@
 #include <stdio.h>
 #include <pwd.h>
 #include <errno.h>
+#include <sys/file.h>
 
 #include "config.h"
 #include "blocks.h"
@@ -44,6 +45,7 @@
 
 char *msgs[]=
  { 
+ "Error, file locked",
  "Error writing file",
  "Error opening file",
  "Error seeking file",
@@ -250,6 +252,13 @@
  if(b->changed) abrerr(b->name);
  if(b && !--b->count)
   {
+#ifdef FILE_LOCKING
+  if (b->flck_fp)
+   {
+   flock(fileno(b->flck_fp),LOCK_UN|LOCK_NB);
+   fclose(b->flck_fp);
+   }
+#endif
   if(b==errbuf) errbuf=0;
   if(b->undo) undorm(b->undo);
   hfreechn(b->eof->hdr);
@@ -1607,9 +1616,10 @@
  * -2 for read error
  * -3 for seek error
  * -4 for open error
+ * -6 for file locked
  */
 
-B *bload(s)
+B *bload(s,trylock)
 char *s;
  {
  char buffer[SEGSIZ];
@@ -1617,6 +1627,7 @@
  B *b;
  long skip,amnt;
  char *n;
+ int islocked = 0;
 
  if(!s || !s[0])
   {
@@ -1639,6 +1650,23 @@
  else if(!zcmp(n,"-")) fi=stdin;
  else fi=fopen(n,"r");
 
+#ifdef FILE_LOCKING
+ if (trylock && n[0] != '!' && zcmp(n,"-") && fi)
+  {
+  int e;
+  if(e=flock(fileno(fi),LOCK_EX|LOCK_NB) && errno==EWOULDBLOCK)
+   {
+   fclose(fi);
+   error= -6;
+   b=bmk(NULL);
+   setopt(&b->o,"");
+   b->rdonly=b->o.readonly;
+   return b;
+   }
+  islocked = 1;
+  }
+#endif
+
  /* Abort if couldn't open */
  if(!fi)
   {
@@ -1668,11 +1696,24 @@
  b=bread(fileno(fi),amnt);
  setopt(&b->o,n);
  b->rdonly=b->o.readonly;
-
+ 
  /* Close stream */
  err:;
- if(s[0]=='!') pclose(fi);
- else if(zcmp(n,"-")) fclose(fi);
+ if(s[0]=='!') 
+  pclose(fi);
+ else if(zcmp(n,"-")) 
+#ifdef FILE_LOCKING
+  if (islocked)
+   b->flck_fp = fi;		/* remember file pointer */
+  else
+   {
+   if (fi)
+   	fclose(fi);
+   b->flck_fp = NULL;
+   }
+#else
+  fclose(fi);
+#endif
 
  opnerr:;
  if(s[0]=='!') ttopnn(), nreturn(maint->t);
@@ -1687,13 +1728,12 @@
 
  /* Eliminate parsed name */
  vsrm(n);
-
  return b;
  }
 
 /* Find already loaded buffer or load file into new buffer */
 
-B *bfind(s)
+B *bfind(s,trylock)
 char *s;
  {
  B *b;
@@ -1715,7 +1755,7 @@
    b->internal=0;
    return b;
    }
- b=bload(s);
+ b=bload(s,trylock);
  b->internal=0;
  return b;
  }
@@ -1908,10 +1948,10 @@
  {
  long tim=time(0);
  B *b;
- FILE *f=fopen("DEADJOE","a");
- fprintf(f,"\n*** Modified files in JOE when it aborted on %s",ctime(&tim));
- if(sig) fprintf(f,"*** JOE was aborted by signal %d\n",sig);
- else fprintf(f,"*** JOE was aborted because the terminal closed\n");
+ FILE *f=fopen("DEADK","a");
+ fprintf(f,"\n*** Modified files in K when it aborted on %s",ctime(&tim));
+ if(sig) fprintf(f,"*** K was aborted by signal %d\n",sig);
+ else fprintf(f,"*** K was aborted because the terminal closed\n");
  fflush(f);
  for(b=bufs.link.next;b!=&bufs;b=b->link.next)
   if(b->changed)
diff -r -u joe2.1/b.h k21/b.h
--- joe2.1/b.h	Mon Sep 19 19:22:35 1994
+++ k21/b.h	Tue Apr  6 15:17:49 1999
@@ -1,6 +1,7 @@
 #ifndef _Ib
 #define _Ib 1
 
+#include <stdio.h>
 #include "config.h"
 #include "queue.h"
 #include "rc.h"
@@ -57,6 +58,9 @@
  P *oldtop;			/* Last top screen position before orphaning */
  int rdonly;			/* Set for read-only */
  int internal;			/* Set for internal buffers */
+#ifdef FILE_LOCKING
+ FILE *flck_fp;			/* file that is locked */
+#endif
  };
 
 extern int force;	/* Set to have final '\n' added to file */
@@ -64,6 +68,7 @@
 
 extern VFILE *vmem;	/* Virtual memory file used for buffer system */
 
+#define MSGS 6		/* number of messages */
 extern char *msgs[];
 
 B *bmk();
diff -r -u joe2.1/cmd.c k21/cmd.c
--- joe2.1/cmd.c	Tue Sep 20 18:04:54 1994
+++ k21/cmd.c	Tue Apr  6 15:17:49 1999
@@ -124,8 +124,11 @@
   { "pbuf", TYPETW, upbuf, 1, "unbuf" },
   { "pedge", TYPETW+TYPEPW+EFIXXCOL, upedge, 1, "nedge" },
   { "pgdn", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOVE, upgdn, 1, "pgup" },
+  { "pgfwd", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOVE, upgfwd, 1, "pgrev" },
+  { "pgrev", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOVE, upgrev, 1, "pgfwd" },
   { "pgup", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOVE, upgup, 1, "pgdn" },
   { "play", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uplay, 1, 0 }, /* EFIXX? */
+  { "playlast", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uplaylast, 1, 0 },
   { "prevpos", TYPETW+TYPEPW+EPOS+EMID+EFIXXCOL, uprevpos, 1, "nextpos" },
   { "prevw", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uprevw, 1, "nextw" },
   { "prevword", TYPETW+TYPEPW+EFIXXCOL+ECHKXCOL, uprvwrd, 1, "nextword" },
Only in k21: grep
diff -r -u joe2.1/help.c k21/help.c
--- joe2.1/help.c	Tue Sep 20 18:05:17 1994
+++ k21/help.c	Tue Apr  6 15:17:50 1999
@@ -158,24 +158,47 @@
 BASE *base;
  {
  W *w=base->parent;
- if(help_structs[helpcursor+1])
+ if(w->t->wind==skiptop) 		/* if help not showing */
   {
-  if(w->t->wind!=skiptop) helpoff(w->t);
-  ++helpcursor;
-  return helpon(w->t);
+  helpcursor = 0;			/* go to first help */
+  return helpon(w->t);			/* and turn it on */
+  }
+ if(help_structs[helpcursor+1])		/* if more helps to show */
+  {
+  if(w->t->wind!=skiptop) 		/* if help showing */
+   helpoff(w->t);			/* turn it off */
+  ++helpcursor;				/* go to next help */
+  return helpon(w->t);			/* and turn it on */
+  }
+ else
+  {
+  helpcursor = 0;			/* go to first help */
+  helpoff(w->t);			/* and turn helps off */
+  return -1;
   }
- else return -1;
  }
 
 int uhprev(base)
 BASE *base;
  {
  W *w=base->parent;
- if(helpcursor)
+ if(w->t->wind==skiptop)		/* if help not showing */
+  {
+  for (helpcursor = 0; help_structs[helpcursor]; helpcursor++);
+  helpcursor--;				/* go to last help */
+  return helpon(w->t);			/* and turn it on */
+  }
+ if(helpcursor)				/* if not on first help (0) */
+  {
+  if(w->t->wind!=skiptop) 		/* if help showing */
+   helpoff(w->t);			/* turn it off */
+  --helpcursor;				/* go to previous help */
+  return helpon(w->t);			/* and turn it on */
+  }
+ else
   {
-  if(w->t->wind!=skiptop) helpoff(w->t);
-  --helpcursor;
-  return helpon(w->t);
+  helpcursor = 0;			/* go to first help */
+  helpoff(w->t);
+  return -1;
   }
- else return -1;
  }
Only in joe2.1: joe.man
diff -r -u joe2.1/joerc k21/joerc
--- joe2.1/joerc	Wed Sep 21 22:07:21 1994
+++ k21/joerc	Tue Apr  6 15:17:50 1999
@@ -22,7 +22,7 @@
 
  -mid		Cursor is recentered when scrolling is necessary
 
- -marking	Text between ^KB and cursor is highlighted (use with -lightoff)
+-marking	Text between ^KB and cursor is highlighted (use with -lightoff)
 
  -asis		Characters 128 - 255 shown as-is
 
@@ -30,7 +30,7 @@
 
  -nobackups	If you don't want backup files to be created
 
- -lightoff	Turn off highlighting after block copy or move
+-lightoff	Turn off highlighting after block copy or move
 
  -exask		^KX always confirms file name
 
Only in k21: k
Only in k21: keys.tpt
Only in k21: krc
diff -r -u joe2.1/macro.c k21/macro.c
--- joe2.1/macro.c	Thu Sep 22 00:04:17 1994
+++ k21/macro.c	Tue Apr  6 15:17:50 1999
@@ -15,7 +15,7 @@
 You should have received a copy of the GNU General Public License along with 
 JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
 675 Mass Ave, Cambridge, MA 02139, USA.  */ 
-
+/*#include <stdio.h>		 for debugging only */
 #include "main.h"
 #include "qw.h"
 #include "pw.h"
@@ -266,6 +266,7 @@
  }
 
 extern int dostaupd;
+static int lastmac = -1;
 
 int ustop()
  {
@@ -275,6 +276,7 @@
   struct recmac *r=recmac;
   MACRO *m;
   dostaupd=1;
+  lastmac = recmac->n;		/* note which one we're stopping */
   recmac=r->next;
   if(kbdmacro[r->n]) rmmacro(kbdmacro[r->n]);
   kbdmacro[r->n]=r->m;
@@ -294,10 +296,17 @@
   {
   int ret;
   c-='0';
+  if (recmac && recmac->n == c)	/* if still recording */
+   {
+   unmac();
+   ustop();			/* close macro before executing */
+   }
   if(playmode[c] || !kbdmacro[c]) return -1;
+
   playmode[c]=1;
   ret=exmacro(kbdmacro[c],0);
   playmode[c]=0;
+  lastmac = c;
   return ret;
   }
  else
@@ -314,6 +323,27 @@
  else
   if(mkqwna(bw,sc("Play-"),doplay,NULL,NULL,NULL)) return 0;
   else return -1;
+ }
+
+/* execute the last keyboard macro -KEB- */
+int uplaylast(w)
+W *w;
+ {
+ if (recmac)			/* if recording some macro */
+  {
+  lastmac = recmac->n;		/* note which one */
+  unmac();
+  ustop();			/* close macro first */
+  }
+ if (lastmac < 0)
+  return -1;
+ /* if that macro playing, or nonexist, return */
+ if(playmode[lastmac] || !kbdmacro[lastmac])
+  return;
+ playmode[lastmac]=1;			/* put in play mode */
+ exmacro(kbdmacro[lastmac]);		/* execute it */
+ playmode[lastmac]=0;
+ return 0;
  }
 
 /* Repeat-count setting */
diff -r -u joe2.1/macro.h k21/macro.h
--- joe2.1/macro.h	Sat Sep 17 08:15:30 1994
+++ k21/macro.h	Tue Apr  6 15:17:50 1999
@@ -60,6 +60,7 @@
 int ustop();
 int urecord();
 int uquery();
+int uplaylast();
 
 /* Repeat prefix user command */
 int uarg();
diff -r -u joe2.1/main.c k21/main.c
--- joe2.1/main.c	Thu Sep 22 22:51:38 1994
+++ k21/main.c	Tue Apr  6 15:17:50 1999
@@ -135,6 +135,34 @@
  else return ret;
  }
 
+char *ktxfile()
+ {
+ static char *fn = 0;
+
+ if (fn)
+  return(fn);	
+ if (!(fn=getenv("HOME")))
+  return(NULL);
+ fn=vsncpy(NULL,0,sz(fn));
+ fn=vsncpy(fn,sLEN(fn),sc("/.ktx"));
+ return(fn);
+ }
+
+void save_context(char *fn, int ln)
+ {
+ FILE *f;
+ char *s;
+	
+/*{FILE *f;f=fopen("/dev/tty8","w");fprintf(f,"Save: %s %d\n",fn,ln);fclose(f);} */
+ if (!(s = ktxfile()))
+  return;
+ if (f = fopen(s,"w"))
+  {
+  fprintf(f,"+%d %s\n",ln+1,fn);
+  fclose(f);
+  }
+ }
+
 int main(argc,argv)
 int argc;
 char *argv[];
@@ -147,7 +175,9 @@
  int omid;
  int backopt;
  int c;
+ FILE *f;
 
+ umask(002);
  if(s=getenv("LINES")) sscanf(s,"%d",&lines);
  if(s=getenv("COLUMNS")) sscanf(s,"%d",&columns);
  if(s=getenv("BAUD")) sscanf(s,"%u",&Baud);
@@ -214,6 +244,23 @@
 
  donerc:
  izhelp();
+
+ if (argc < 2 && (f=fopen(ktxfile(),"r")))	/* if no args given */
+  {
+  char fline[256];
+  char *t;
+	  		
+  fgets(fline,256,f);
+  t = argv[1] = fline;
+  while( *t && !isspace(*t)) t++;
+  *t++ = 0;					/* null terminate */
+  argv[2] = t;
+  while( *t && !isspace(*t)) t++;
+  *t=0;						/* null terminate */
+  argv[argc = 3] = NULL;
+  fprintf(stderr,"Resuming %s at line %s.\n",argv[2],argv[1]);
+  }
+
  for(c=1;argv[c];++c)
   if(argv[c][0]=='-' && argv[c][1])
    switch(glopt(argv[c]+1,argv[c+1],NULL,1))
@@ -239,13 +286,13 @@
    }
   else
    {
-   B *b=bfind(argv[c]);
+   B *b=bfind(argv[c],1);
    BW *bw;
    int er=error;
    if(!orphan || !opened)
     {
     bw=wmktw(maint,b);
-    if(er) msgnwt(bw,msgs[5+er]);
+    if(er) msgnwt(bw,msgs[MSGS+er]);
     }
    else b->orphan=1;
    bw->o.readonly=bw->b->rdonly;
@@ -274,7 +321,7 @@
   mid=omid;
   }
  else
-  wmktw(maint,bfind(""));
+  wmktw(maint,bfind("",0));
  if(help) helpon(maint);
  if(!nonotice)
   msgnw(lastw(maint)->object,"\\i** Joe's Own Editor v2.1 ** Copyright (C) 1994 Joseph H. Allen **\\i");
Only in k21: test.fm
Only in k21: test.lst
Only in k21: test1.lst
Only in k21: test2.lst
Only in k21: test3.lst
Only in k21: test4.lst
diff -r -u joe2.1/tw.c k21/tw.c
--- joe2.1/tw.c	Wed Sep 21 16:08:59 1994
+++ k21/tw.c	Tue Apr  6 15:17:50 1999
@@ -313,6 +313,9 @@
 W *w=bw->parent;
 B *b;
 TW *tw=(TW *)bw->object;
+char *fnamstrg = 0;
+int exitline;
+
 if(notify) *notify=1;
 if(k!='y' && k!='Y') return -1;
 
@@ -335,6 +338,8 @@
   exmsg=vsncpy(exmsg,sLEN(exmsg),sz(" not saved."));
   }
  else exmsg=vsncpy(NULL,0,sz("File (Unnamed) not saved."));
+
+#ifdef VERBOSE_EXIT_MESSAGE
 else if(!exmsg)
  if(bw->b->name)
   {
@@ -343,12 +348,23 @@
   exmsg=vsncpy(exmsg,sLEN(exmsg),sz(" not changed so no update needed."));
   }
  else exmsg=vsncpy(NULL,0,sz("File (Unnamed) not changed so no update needed."));
+#endif
+
+fnamstrg = vsncpy(NULL,0,sz(bw->b->name));/* remember filename */
+exitline = bw->cursor->line;		/* and exit line number */
 bwrm(bw);
 vsrm(tw->stalin);
 free(tw);
 w->object=0;
 wabort(w);		/* Eliminate this window and it's children */
-if(!leave) if(exmsg) vsrm(exmsg), exmsg=0;
+if(leave)
+ save_context(fnamstrg,exitline);/* save the context file */
+else
+ {
+ vsrm(fnamstrg);				/* clear filename string space */
+ if(exmsg)
+  vsrm(exmsg), exmsg=0;
+ }
 return 0;
 }
 
@@ -509,3 +525,4 @@
  iztw(tw,w->y);
  return bw;
  }
+
diff -r -u joe2.1/ublock.c k21/ublock.c
--- joe2.1/ublock.c	Wed Sep 21 22:09:36 1994
+++ k21/ublock.c	Tue Apr  6 15:17:50 1999
@@ -463,7 +463,7 @@
    int fl;
    int ret=0;
    B *tmp=pextrect(markb,markk->line-markb->line+1,markk->xcol);
-   if(fl=bsave(tmp->bof,s,tmp->eof->byte)) msgnw(bw,msgs[5+fl]), ret= -1;
+   if(fl=bsave(tmp->bof,s,tmp->eof->byte)) msgnw(bw,msgs[MSGS+fl]), ret= -1;
    brm(tmp);
    if(lightoff) unmark(bw);
    vsrm(s);
@@ -473,7 +473,7 @@
    {
    int fl;
    int ret=0;
-   if(fl=bsave(markb,s,markk->byte-markb->byte)) msgnw(bw,msgs[5+fl]), ret= -1;
+   if(fl=bsave(markb,s,markk->byte-markb->byte)) msgnw(bw,msgs[MSGS+fl]), ret= -1;
    if(lightoff) unmark(bw);
    vsrm(s);
    return ret;
@@ -657,10 +657,10 @@
    long width=markk->xcol-markb->xcol;
    long height;
    int usetabs=ptabrect(markb,markk->line-markb->line+1,markk->xcol);
-   tmp=bload(s); 
+   tmp=bload(s,0); 
    if(error)
     {
-    msgnw(bw,msgs[error+5]);
+    msgnw(bw,msgs[error+MSGS]);
     brm(tmp);
     return -1;
     }
@@ -687,8 +687,8 @@
  else
   {
   int ret=0;
-  B *tmp=bload(s);
-  if(error) msgnw(bw,msgs[error+5]), brm(tmp), ret= -1;
+  B *tmp=bload(s,0);
+  if(error) msgnw(bw,msgs[error+MSGS]), brm(tmp), ret= -1;
   else binsb(bw->cursor,tmp);
   vsrm(s);
   bw->cursor->xcol=piscol(bw->cursor);
@@ -795,7 +795,9 @@
   }
  vsrm(s);
  ttopnn();
- if(filtflg) umarkb(bw), umarkk(bw);
+#ifdef ORIGINAL		/* this leaves block mark on after a filter */
+if(filtflg) umarkb(bw), umarkk(bw);
+#endif
  bw->cursor->xcol=piscol(bw->cursor);
  return 0;
  }
diff -r -u joe2.1/uedit.c k21/uedit.c
--- joe2.1/uedit.c	Thu Sep 22 22:59:13 1994
+++ k21/uedit.c	Tue Apr  6 15:17:50 1999
@@ -395,6 +395,26 @@
  return 0;
  }
 
+int upgfwd(bw)		/* page forward in J compatible mode -KEB- */
+BW *bw;
+ {
+ if (bw->cursor->line - bw->top->line < bw->h - 1)	/* not on last line? */
+  ubos(bw);
+ else
+  scrdn(bw,bw->h,1);
+/*  upgdn(bw); */
+ }
+
+int upgrev(bw)		/* page back in J compatible mode -KEB- */
+BW *bw;
+ {
+ if (bw->cursor->line - bw->top->line)	/* not on first line? */
+  utos(bw);
+ else
+  scrup(bw,bw->h,1);
+/*  upgup(bw); */
+ }
+
 /* Scroll by a single line.  The cursor moves with the scroll */
 
 int uupslide(bw)
diff -r -u joe2.1/uedit.h k21/uedit.h
--- joe2.1/uedit.h	Sat Sep 17 08:15:30 1994
+++ k21/uedit.h	Tue Apr  6 15:17:50 1999
@@ -65,5 +65,7 @@
 int ubyte();
 int ucol();
 int utxt();
+int upgfwd();
+int upgrev();
 
 #endif
diff -r -u joe2.1/ufile.c k21/ufile.c
--- joe2.1/ufile.c	Wed Sep 21 00:43:05 1994
+++ k21/ufile.c	Tue Apr  6 15:17:50 1999
@@ -17,6 +17,8 @@
 675 Mass Ave, Cambridge, MA 02139, USA.  */ 
 
 #include <stdio.h>
+#include <time.h>
+#include <pwd.h>
 #include "config.h"
 #include "b.h"
 #include "bw.h"
@@ -98,21 +100,36 @@
   else name=vsncpy(name,0,sz(bw->b->name));
   name=vsadd(name,'~');
 
-  /* Attempt to delete backup file first */
-  unlink(name);
-
   /* Create command string */
   s=vsncpy(s,0,sc("/bin/cp "));
   s=vsncpy(s,sLEN(s),sz(bw->b->name));
   s=vsadd(s,' ');
+
+#ifdef UNIQUE_BACKUPS
+  {
+  char ts[32];
+  time_t t;
+  struct passwd *pwp = getpwuid(getuid());	
+  time(&t);
+  strftime(ts,32,"%d-%b-%y_%H:%M:%S~",localtime(&t));
+  name=vsncpy(name,sLEN(name),sz(ts));
+  name=vsncpy(name,sLEN(name),sz(pwp->pw_name));
+  }
+#else
+  unlink(name);  /* Attempt to delete backup file */
+#endif
+
   s=vsncpy(s,sLEN(s),sv(name));
   s=vsncpy(s,sLEN(s),sc(" 2>/dev/null"));
-
   tickoff();
   if(system(s))
    {
+   char *ms = 0;
    tickon();
-   msgnw(bw,"Couldn't make backup file... file not saved");
+   ms=vsncpy(ms,0,sc("Can't create backup file: "));
+   ms=vsncpy(ms,sLEN(ms),sv(name));
+   msgnw(bw,ms);
+   vsrm(ms);
    vsrm(s);
    vsrm(name);
    return 1;
@@ -142,7 +159,7 @@
  if(backup(bw)) { vsrm(s); return -1; }
  if(fl=bsave(bw->b->bof,s,bw->b->eof->byte))
   {
-  msgnw(bw,msgs[fl+5]);
+  msgnw(bw,msgs[fl+MSGS]);
   vsrm(s);
   return -1;
   }
@@ -195,8 +212,13 @@
   msgnw(bw,"Process running in this window");
   return -1;
   }
- b=bfind(s);
+ b=bfind(s,1);
  er=error;
+ if(er == -5)
+  {
+  msgnw(bw,msgs[MSGS+er]);
+  return -1;
+  }
  if(bw->b->count==1 && (bw->b->changed || bw->b->name))
   if(orphan) orphit(bw);
   else
@@ -210,7 +232,7 @@
    }
  if(er)
   {
-  msgnwt(bw,msgs[er+5]);
+  msgnwt(bw,msgs[er+MSGS]);
   if(er!= -1) ret= -1;
   }
  object=bw->object;
@@ -259,10 +281,10 @@
   msgnw(bw,"Process running in this window");
   return -1;
   }
- b=bfind(s);
+ b=bfind(s,1);
  if(error)
   {
-  msgnwt(bw,msgs[error+5]);
+  msgnwt(bw,msgs[error+MSGS]);
   if(error!= -1) ret= -1;
   }
  if(bw->b->count==1 && (bw->b->changed || bw->b->name))
@@ -451,7 +473,7 @@
  if(bw->b->count==1) bw->b->changed=0;
  object=bw->object; w=bw->parent;
  bwrm(bw);
- w->object=(void *)(bw=bwmk(w,bfind(""),0));
+ w->object=(void *)(bw=bwmk(w,bfind("",0),0));
  wredraw(bw->parent);
  bw->object=object;
  return 0;
diff -r -u joe2.1/undo.c k21/undo.c
--- joe2.1/undo.c	Fri Sep 23 00:11:30 1994
+++ k21/undo.c	Tue Apr  6 15:17:50 1999
@@ -431,7 +431,9 @@
    binsb(bw->cursor,bcpy(b->bof,b->eof));
    boffline(b);
    }
-  pfwrd(bw->cursor,ptr->len);
+#ifdef END_OF_YANK
+  pfwrd(bw->cursor,ptr->len);		/* move to end of yanked text */
+#endif
   yankbuf=bw->b;
   yankwhere=bw->cursor->byte;
   return 0;
diff -r -u joe2.1/vs.c k21/vs.c
--- joe2.1/vs.c	Fri Sep 23 13:50:43 1994
+++ k21/vs.c	Tue Apr  6 15:17:50 1999
@@ -25,8 +25,8 @@
 int sicmp(a,b)
 char a,b;
 {
-if(a>='A' || a<='Z') a+='a'-'A';
-if(b>='A' || b<='Z') b+='a'-'A';
+if(a>='A' && a<='Z') a+='a'-'A';
+if(b>='A' && b<='Z') b+='a'-'A';
 return scmp(a,b);
 }
 
